<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Why NetOffice? | NetOffice Framework </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Why NetOffice? | NetOffice Framework ">
    <meta name="generator" content="docfx 2.3.1.0">
    
    <link rel="shortcut icon" href="../favicon.ico">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
  </head>
  <body data-spy="scroll" data-target="#affix">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
              <h2 id="why-netoffice">Why NetOffice?</h2>
              
<p>The usual methods for accessing Microsoft Office. NET are the Primary Interop Assemblies and VSTO. Both access methods involve various disadvantages.</p>
<ul>
<li>They are limited to a version, i.e. they only work with one or certain versions of Office</li>
<li>They cause problems while transferring or installation on other systems</li>
<li>They offer no protection mechanism in the management of COM proxies</li>
</ul>
<p>NetOffice eliminates these disadvantages and remains a 1:1 wrapper that is syntactically and semantically identical to the interop assemblies.</p>
<h2 id="how-does-netoffice-work">How does NetOffice work?</h2>
<p>NetOffice used to access only LateBinding Calls via COM Interop, but without sacrificing the convenience and simplicity of EarlyBind calls. The slim architecture and efficient design makes this only slightly slower than so-called EarlyBind calls in .NET (max. 10%). Events in NetOffice are implemented with a technique the author calls Dynamic EarlyBinding. Learn more about this in the technical documentation.</p>
<h2 id="netoffice-contains-a-number-of-assemblies-why-and-which-assemblies-do-i-need-for-my-desired-office-application">NetOffice contains a number of assemblies. Why and which assemblies do I need for my desired Office application?</h2>
<p>All Office applications use types which are defined in other components/type libraries. These dependent type libraries are therefore given as an independent assembly. Each assembly also requires the NetOffice.dll assembly.  An overview which Office application integrates which additional assemblies can be found here.</p>
<h3 id="deployment-table">Deployment Table:</h3>
<table>
<thead>
<tr>
<th>Office applications</th>
<th>Dependencies</th>
</tr>
</thead>
<tbody>
<tr>
<td>ExcelApi.dll</td>
<td></td>
</tr>
<tr>
<td></td>
<td>OfficeApi.dll</td>
</tr>
<tr>
<td></td>
<td>VBIDEApi.dll</td>
</tr>
<tr>
<td></td>
<td>NetOffice.dll</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>WordApi.dll</td>
<td></td>
</tr>
<tr>
<td></td>
<td>OfficeApi.dll</td>
</tr>
<tr>
<td></td>
<td>VBIDEApi.dll</td>
</tr>
<tr>
<td></td>
<td>NetOffice.dll</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>OutlookApi.dll</td>
<td></td>
</tr>
<tr>
<td></td>
<td>OfficeApi.dll</td>
</tr>
<tr>
<td></td>
<td>VBIDEApi.dll</td>
</tr>
<tr>
<td></td>
<td>NetOffice.dll</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>PowerPointApi.dll</td>
<td></td>
</tr>
<tr>
<td></td>
<td>OfficeApi.dll</td>
</tr>
<tr>
<td></td>
<td>VBIDEApi.dll</td>
</tr>
<tr>
<td></td>
<td>NetOffice.dll</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>AccessApi.dll</td>
<td></td>
</tr>
<tr>
<td></td>
<td>OfficeApi.dll</td>
</tr>
<tr>
<td></td>
<td>DAOApi.dll</td>
</tr>
<tr>
<td></td>
<td>VBIDEApi.dll</td>
</tr>
<tr>
<td></td>
<td>ADODBApi.dll</td>
</tr>
<tr>
<td></td>
<td>OWC10Api.dll</td>
</tr>
<tr>
<td></td>
<td>MSDATASRCApi.dll</td>
</tr>
<tr>
<td></td>
<td>MSComctlLibApi.dll</td>
</tr>
<tr>
<td></td>
<td>NetOffice.dll</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>MSProjectApi.dll</td>
<td></td>
</tr>
<tr>
<td></td>
<td>OfficeApi.dll</td>
</tr>
<tr>
<td></td>
<td>VBIDEApi.dll</td>
</tr>
<tr>
<td></td>
<td>MSHTMLApi.dll</td>
</tr>
<tr>
<td></td>
<td>NetOffice.dll</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>VisioApi.dll</td>
<td></td>
</tr>
<tr>
<td></td>
<td>OfficeApi.dll</td>
</tr>
<tr>
<td></td>
<td>VBIDEApi.dll</td>
</tr>
<tr>
<td></td>
<td>NetOffice.dll</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>MSFormsApi.dll</td>
<td></td>
</tr>
<tr>
<td></td>
<td>VisioApi.dll</td>
</tr>
<tr>
<td></td>
<td>OfficeApi.dll</td>
</tr>
<tr>
<td></td>
<td>VBIDEApi.dll</td>
</tr>
<tr>
<td></td>
<td>NetOffice.dll</td>
</tr>
</tbody>
</table>
<h2 id="what-do-i-have-to-do-to-deliver-my-application-with-netoffice">What do I have to do to deliver my application with NetOffice?</h2>
<p>Nothing except copying the needed assemblies to the target system. You don&#39;t need a registration or something like that with the exception of COMAddIns. Managed COMAddins generally have to be registered via the .Net Utility RegAsm.exe or the Windows Installer do that or you.</p>
<h2 id="do-comaddins-also-work-version-independent">Do COMAddins also work version independent?</h2>
<p>Yes, of course. This is a particular strength of NetOffice. See the code examples for example project for all Office applications but you have to create 2 Addins for 32/64 Bit support.</p>
<h2 id="is-netoffice-ready-for-multiple-platforms-32-64-bit">Is NetOffice ready for multiple platforms (32/64 Bit)?</h2>
<p>You can use the NetOffice AnyCPU assemblies in all scenarios. his is true regardless wether you develop for a 32Bit Office application or a 64Bit Office application, even independent on which platform these are installed. If your assembly is a standalone application (.exe) or is being loaded by one, you can compile your assembly as AnyCPU without worries.</p>
<p>If your assembly is a COMAddin that is being loaded by a 32Bit Office application, you can still compile it as AnyCPU. If you develop a COMAddin that is being used by a 64Bit Office application, you have to compile your assembly as x64. If you wart to support 32Bit and 64Bit Office applications, you may need to provide a second x64-compiled COMAddin. This behaviour is the same in all scenarios(interop,vsto or netoffice). A 64Bit application can only load 64Bit Dll&#39;s.If you use a 64Bit Office for testing on your development system and you want to register your COMAddin while compiling (Register for COM Interop), you need to keep in mind that some older versions of Visual Studio call the 32Bit registration in that case. In this case, you get the following error:</p>
<pre><code>&quot;File &lt;path to assembly&gt; is not a valid assembly&quot;
</code></pre><p>You can read a workarround by Microsoft here: <a href="https://support.microsoft.com/en-us/kb/956933">Issues with building a project with &quot;Register for COM interop&quot; for a 64-bit assembly
</a></p>
<h2 id="how-do-i-migrate-my-solution-to-netoffice">How do I migrate my solution to NetOffice?</h2>
<h3 id="interop-solutions">Interop Solutions</h3>
<p>Change the references and the using(imports in vb) statements. Occasionally, you need to make some adjustments to event triggers. You have to replace all Marshall.ReleaseComObject calls with Dispose. you can also delete the most ReleaseComObject calls because NetOffice manages COM proxies for you. Read more about in the technical documentation: Understanding COM Proxy Management</p>
<h3 id="vba-solutions">VBA Solutions</h3>
<p>Developers there want changing a VBA solution to VB.NET and NetOffice has to know that VB.NET is syntactical similar to VBA but has also some different concepts. If you have good VB.NET skills then you have no problems to migrate your solution to NetOffice.</p>
<h2 id="com-proxy-management">COM proxy management</h2>
<p>If you call Office applications (COM servers) .NET returns instead of real objects so-called COM proxies. In order to signal the COM server that you no longer need this, you have to free it with a special method. This applies to VSTO as well as to interop assemblies.</p>
<p>Due to this fact, you must not use no objects implicitly or use Enumerator directly because it then can no longer be released. In NetOffice each object provides the method Dispose() for when you do not need it anymore. All classes in NetOffice implement the IDisposable interface and also provide the Dispose() method. However, you do not have to call Dispose() for every used object and you may also use objects implicitly and Enumerator directly without having to worry about releasing ti afterwards. NetOffice generated proxies stored in a separate table and frees when you request it or a parent object is being released. More on that in the technical documentation and Tutorial01.</p>
<h2 id="unknown-and-variant-types">Unknown and Variant Types</h2>
<p>Many office applications include Properties, return values ​​or parameter whose type is not known at design time and which can change at run time, depending on context. There is a difference between unknown COM proxies and the variant data type which has its roots in the Visual Basic for Applications (VBA).</p>
<p>Unknown COM proxies in NetOffice have the type COMObject. Each class in NetOffice also inherits from this type. The declaration of unkown proxies is Object since NetOffice 1.5.1 as special service for VB developers to use the integrated late binding feature. You can also convert an anonymous COM proxy at run-time into the actual type without problems.</p>
<p>The variant data type is used in VBA for any type to accept both a COM proxy and a scalar data type such as bool or int. In NetOffice that type is replaced by the type object. If a Variant Property is a COM proxy at run time you get an object of the corresponding NetOffice wrapper class, otherwise the the corresponding scalar data type. More on that in the technical documentation and Tutorial06.</p>
<h2 id="if-netoffice-supports-all-versions-of-office-how-do-i-know-which-office-version-offers-which-functionality">If NetOffice supports all versions of Office, how do I know which Office version offers which functionality?</h2>
<p>All classes, properties, methods, enums, etc. come with XML Documentation and have a special attribute that identifies which office version(s)  this entity support. You get this information displayed during development also through IntelliSense. Moreover, it is possible to examine an assembly (created with NetOffice) with NetOffice.DeveloperToolbox which Office versions are used practically. Use this opportunity before shipping your assembly to make sure that your program works with the Office versions that you (or your customers) have specified.</p>
<p><img src="assets/NetOffice_IntelliSense.jpg" alt="IntelliSense support in C# for version information of a property."></p>

            </article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
            <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
            </nav>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            Copyright © 2016 NetOffice Framework.<br>Documentation licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0<a></a>.
            
          </a></div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </body>
</html>
